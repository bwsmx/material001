<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>People Counter</title>
  <meta name="robots" content="noindex,nofollow" />
  <style>
    :root { --bg:#ffffff; --fg:#111; --muted:#666; --border:#e5e5e5; --ok:#10b981; --warn:#f59e0b; --danger:#f43f5e; --over:#dc2626; }
    *{box-sizing:border-box}
    html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    .app{min-height:100%;display:flex;flex-direction:column}
    .topbar{display:flex;align-items:center;justify-content:space-between;padding:12px 16px;border-bottom:1px solid var(--border);position:sticky;top:0;background:var(--bg);z-index:2}
    .title{font-weight:600;letter-spacing:-.01em}
    .chip{display:inline-flex;align-items:center;gap:6px;margin-left:8px;padding:4px 8px;border:1px solid var(--border);border-radius:999px;font-size:12px;color:#333;background:#fff}
    .iconbtn{border:1px solid var(--border);background:#fff;padding:8px 10px;border-radius:12px;font-size:14px}
    .wrap{width:100%;max-width:520px;margin:0 auto;padding:20px 16px 36px}
    .bar{height:10px;background:#eee;border-radius:999px;overflow:hidden}
    .fill{height:100%;width:0%;transition:width .2s linear}
    .meta{display:flex;align-items:center;justify-content:space-between;font-size:12px;color:var(--muted);margin-top:6px}
    .big{font-size:88px;line-height:1;font-weight:700;letter-spacing:-.02em;margin:20px 0 6px}
    .sub{font-size:13px;color:var(--muted)}
    .grid2{display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:24px}
    .btn{height:96px;border-radius:18px;border:1px solid var(--border);font-size:40px;font-weight:700;background:#f7f7f7}
    .btn.primary{background:#111;color:#fff;border-color:#111}
    .hint{text-align:center;font-size:12px;color:var(--muted);margin-top:10px}
    .sheetBack{position:fixed;inset:0;background:rgba(0,0,0,.4);display:none;align-items:end;z-index:10}
    .sheet{background:#fff;width:100%;max-height:90%;overflow:auto;border-radius:16px 16px 0 0;padding:12px}
    .sheet.desktop{max-width:720px;margin:40px auto;border-radius:16px}
    .row{display:flex;align-items:center;justify-content:space-between;gap:12px;padding:8px 0}
    .label{font-size:14px}
    .input{width:160px;padding:8px 10px;border:1px solid var(--border);border-radius:12px;font-size:14px}
    .input.wide{width:100%;max-width:100%}
    .pill{padding:6px 10px;border:1px solid var(--border);border-radius:999px;background:#fff;font-size:13px}
    .toggle{width:42px;height:26px;background:#ddd;border-radius:999px;position:relative;cursor:pointer}
    .toggle .dot{position:absolute;top:3px;left:3px;width:20px;height:20px;border-radius:50%;background:#fff;transition:left .15s;border:1px solid #ddd}
    .toggle.on{background:#111}
    .toggle.on .dot{left:19px}
    .section{border-top:1px solid var(--border);margin-top:8px;padding-top:8px}
    .small{font-size:12px;color:var(--muted)}
    .list{margin:8px 0;padding:0;list-style:none}
    .item{display:flex;align-items:center;justify-content:space-between;padding:6px 0;border-bottom:1px dashed #f0f0f0;font-size:13px}
    .badge{font-size:12px;border:1px solid var(--border);padding:2px 6px;border-radius:8px}
    .pass{background:#ecfdf5;color:#065f46;border-color:#a7f3d0}
    .fail{background:#fef2f2;color:#991b1b;border-color:#fecaca}
    .status{font-size:12px;color:var(--muted)}
    .mutedBtn{background:#fafafa}
    @media(min-width:768px){.sheetBack{align-items:center}.sheet{border-radius:16px}.sheet.desktop{max-height:80%}}
  </style>
</head>
<body>
  <div class="app">
    <div class="topbar">
      <div class="title">People Counter <span id="counterChip" class="chip" title="Active counter">üè∑Ô∏è <span id="chipText">Main Entrance</span></span></div>
      <button id="settingsBtn" class="iconbtn" aria-label="Settings">‚öôÔ∏è</button>
    </div>

    <div class="wrap">
      <div class="bar"><div id="fill" class="fill"></div></div>
      <div class="meta"><div id="maxLabel">Max 300</div><div><span id="syncDot" style="display:inline-block;width:8px;height:8px;border-radius:50%;background:#bbb;margin-right:6px"></span><span id="syncLabel" class="status">Offline</span> ¬∑ <span id="pctLabel">0%</span></div></div>

      <div id="count" class="big">0</div>
      <div id="sub" class="sub">Inside ¬∑ Total today 0 ¬∑ Remaining 300</div>

      <div class="grid2">
        <button id="exitBtn" class="btn" aria-label="Exit">‚àí</button>
        <button id="enterBtn" class="btn primary" aria-label="Enter">+</button>
      </div>
      <div class="hint">Shortcuts: E = +1 ¬∑ X = ‚àí1 ¬∑ U = undo ¬∑ R = clear</div>
    </div>
  </div>

  <div id="sheetBack" class="sheetBack" role="dialog" aria-modal="true" aria-labelledby="sheetTitle">
    <div class="sheet desktop" id="sheet" onclick="event.stopPropagation()">
      <div class="row">
        <div id="sheetTitle" class="title">Settings</div>
        <button id="doneBtn" class="iconbtn">Done</button>
      </div>

      <div class="row">
        <div class="label">Maximum capacity (per counter)</div>
        <div>
          <input id="capInput" type="number" min="1" class="input" />
          <button class="pill" data-cap="100">100</button>
          <button class="pill" data-cap="250">250</button>
          <button class="pill" data-cap="500">500</button>
          <button class="pill" data-cap="1000">1000</button>
        </div>
      </div>

      <div class="row">
        <div class="label">Lockout at capacity (per counter)</div>
        <div id="lockToggle" class="toggle"><div class="dot"></div></div>
      </div>

      <div class="row">
        <div class="label">Batch size</div>
        <div>
          <button class="pill" data-batch="1">1</button>
          <button class="pill" data-batch="2">2</button>
          <button class="pill" data-batch="5">5</button>
          <button class="pill" data-batch="10">10</button>
          <button class="pill" data-batch="20">20</button>
        </div>
      </div>

      <div class="section">
        <div class="row"><div class="label">Day controls</div>
          <div>
            <button id="undoBtn" class="pill">Undo</button>
            <button id="clearBtn" class="pill">Clear floor</button>
            <button id="newDayBtn" class="pill">New day</button>
          </div>
        </div>
        <div class="small" id="sinceLabel">Current start: ‚Äî</div>
      </div>

      <div class="section">
        <div class="row"><div class="label">Counters</div>
          <div class="small">Create & select which counter this device controls. Capacity/lockout are saved per counter.</div>
        </div>
        <ul id="countersList" class="list"></ul>
        <div class="row">
          <div class="label">Add counter</div>
          <div style="display:flex;gap:8px;flex-wrap:wrap;align-items:center">
            <input id="newCounterLabel" class="input" placeholder="Label e.g. Terrace Stairs" />
            <input id="newCounterId" class="input" placeholder="ID e.g. terrace-stairs" />
            <button id="addCounterBtn" class="pill mutedBtn">Add</button>
          </div>
        </div>
      </div>

      <div class="section">
        <div class="row"><div class="label">History (last 20)</div><div class="small">Newest first ¬∑ filtered by active counter</div></div>
        <ul id="history" class="list"></ul>
      </div>

      <div class="section">
        <div class="row"><div class="label">Export</div>
          <div>
            <button id="csvBtn" class="pill">Download CSV</button>
          </div>
        </div>
      </div>

      <div class="section">
        <div class="row"><div class="label">Connectivity</div>
          <div class="small">Endpoint is optional; the app works offline and queues events.</div>
        </div>
        <div class="row">
          <div class="label">Endpoint URL</div>
          <div style="flex:1;max-width:420px">
            <input id="endpointInput" class="input wide" placeholder="https://script.google.com/macros/s/AKf.../exec" />
          </div>
        </div>
        <div class="row">
          <div class="label">Session ID</div>
          <div>
            <input id="sessionInput" class="input" placeholder="2025-02-10" />
          </div>
        </div>
        <div class="row">
          <div class="label">Counter ID</div>
          <div>
            <input id="counterInput" class="input" placeholder="main-entrance" />
          </div>
        </div>
        <div class="row">
          <div class="label">Counter Label</div>
          <div>
            <input id="counterLabelInput" class="input" placeholder="Main Entrance" />
          </div>
        </div>
        <div class="row">
          <div class="label">Actions</div>
          <div>
            <button id="testConnBtn" class="pill">Test connection</button>
            <button id="flushBtn" class="pill">Flush queue</button>
          </div>
        </div>
      </div>

      <div class="section">
        <div class="row"><div class="label">Diagnostics</div>
          <div><button id="testBtn" class="pill">Run tests</button></div>
        </div>
        <ul id="tests" class="list"></ul>
        <div id="envWarn" class="small" style="display:none; margin-top:6px;"></div>
      </div>

      <div class="section">
        <div class="row"><div class="label">Settings PIN</div>
          <div>
            <input id="pinInput" type="password" class="input" placeholder="Set 4‚Äëdigit PIN" />
            <button id="setPinBtn" class="pill">Save PIN</button>
          </div>
        </div>
        <div class="small">If empty, default PIN is 1234.</div>
      </div>

    </div>
  </div>

  <script>
    // ---- Safe storage helpers ----
    const KEYS = { state:'pc_state_v9', capacity:'pc_capacity_v9', lock:'pc_lock_v9', batch:'pc_batch_v9', pin:'pc_pin_v9', endpoint:'pc_endpoint_v9', session:'pc_session_v9', counter:'pc_counter_v9', counterLabel:'pc_counter_label_v9', counters:'pc_counters_v9', queue:'pc_queue_v9', migrated:'pc_migrated_v9' };
    const sget = (k, d)=>{ try{ const v = localStorage.getItem(k); return v==null? d : JSON.parse(v);}catch{ return d; } };
    const sset = (k, v)=>{ try{ localStorage.setItem(k, JSON.stringify(v)); }catch{} };

    // ---- Legacy key migration (so Endpoint/Session persist across versions) ----
    function readLegacy(keys){ for(const k of keys){ try{ const v = localStorage.getItem(k); if(v!=null) return JSON.parse(v);}catch{} } return null; }

    // ---- State ----
    const state = sget(KEYS.state, { inside:0, total:0, peak:0, history:[], createdAt:Date.now() });
    // legacy globals (will migrate into per-counter)
    let legacyCapacity = sget(KEYS.capacity, 300);
    let legacyLockout = sget(KEYS.lock, false);
    let batch = sget(KEYS.batch, 1);
    let pin = sget(KEYS.pin, '1234');

    // Attempt to load current values, else pull from v8/v7
    let endpoint = sget(KEYS.endpoint, '') || readLegacy(['pc_endpoint_v8','pc_endpoint_v7']) || '';
    let sessionId = sget(KEYS.session, new Date().toISOString().slice(0,10)) || readLegacy(['pc_session_v8','pc_session_v7']) || new Date().toISOString().slice(0,10);
    let counterId = sget(KEYS.counter, 'main-entrance') || readLegacy(['pc_counter_v8','pc_counter_v7']) || 'main-entrance';
    let counterLabel = sget(KEYS.counterLabel, 'Main Entrance') || readLegacy(['pc_counter_label_v8','pc_counter_label_v7']) || 'Main Entrance';

    let counters = sget(KEYS.counters, [
      { id:'main-entrance', label:'Main Entrance', cap: legacyCapacity, lockout: legacyLockout },
      { id:'terrace-stairs', label:'Terrace Stairs', cap: legacyCapacity, lockout: legacyLockout }
    ]);
    // ensure active counter exists & has cap/lockout
    (function ensureActive(){
      if(!counters.find(c=>c.id===counterId)) counters.push({id:counterId, label:counterLabel, cap: legacyCapacity, lockout: legacyLockout});
      counters = counters.map(c=>({ id:c.id, label:c.label, cap: (typeof c.cap==='number'&&c.cap>0)? c.cap : legacyCapacity, lockout: !!c.lockout }));
    })();

    // One-time write-back after migration so future loads read v9 keys
    (function maybeMigrate(){
      if(!sget(KEYS.migrated,false)){
        sset(KEYS.endpoint, endpoint); sset(KEYS.session, sessionId); sset(KEYS.counter, counterId); sset(KEYS.counterLabel, counterLabel); sset(KEYS.counters, counters); sset(KEYS.migrated,true);
      }
    })();

    let queue = sget(KEYS.queue, []); // array of pending events

    // ---- Elements ----
    const countEl = document.getElementById('count');
    const subEl = document.getElementById('sub');
    const fillEl = document.getElementById('fill');
    const pctLabel = document.getElementById('pctLabel');
    const maxLabel = document.getElementById('maxLabel');
    const enterBtn = document.getElementById('enterBtn');
    const exitBtn = document.getElementById('exitBtn');

    const sheetBack = document.getElementById('sheetBack');
    const settingsBtn = document.getElementById('settingsBtn');
    const doneBtn = document.getElementById('doneBtn');

    const capInput = document.getElementById('capInput');
    const lockToggle = document.getElementById('lockToggle');
    const undoBtn = document.getElementById('undoBtn');
    const clearBtn = document.getElementById('clearBtn');
    const newDayBtn = document.getElementById('newDayBtn');
    const sinceLabel = document.getElementById('sinceLabel');
    const historyEl = document.getElementById('history');

    const countersList = document.getElementById('countersList');
    const newCounterLabel = document.getElementById('newCounterLabel');
    const newCounterId = document.getElementById('newCounterId');
    const addCounterBtn = document.getElementById('addCounterBtn');

    const csvBtn = document.getElementById('csvBtn');

    const testBtn = document.getElementById('testBtn');
    const testsEl = document.getElementById('tests');
    const envWarn = document.getElementById('envWarn');

    const endpointInput = document.getElementById('endpointInput');
    const sessionInput = document.getElementById('sessionInput');
    const counterInput = document.getElementById('counterInput');
    const counterLabelInput = document.getElementById('counterLabelInput');
    const testConnBtn = document.getElementById('testConnBtn');
    const flushBtn = document.getElementById('flushBtn');
    const syncLabel = document.getElementById('syncLabel');
    const syncDot = document.getElementById('syncDot');

    const pinInput = document.getElementById('pinInput');
    const setPinBtn = document.getElementById('setPinBtn');

    const chipText = document.getElementById('chipText');

    // ---- Utils ----
    const fmtTime = (t)=> new Date(t).toLocaleTimeString();
    const fmtDate = (t)=> new Date(t).toLocaleString();
    const clamp0 = (n)=> Math.max(0, n|0);
    const percent = (a,b)=> (!b||b<=0)?0:Math.min(100, Math.max(0, Math.round((a/b)*100)));
    const haptic = ()=>{ try{ if(navigator.vibrate) navigator.vibrate(10);}catch{} };

    function active(){ return counters.find(c=>c.id===counterId) || counters[0]; }

    function replay(history, createdAt){
      // Recompute only for the ACTIVE counter
      let start=-1; for(let i=history.length-1;i>=0;i--){ if(history[i].type==='newDay'){ start=i; break; } }
      let inside=0,total=0,peak=0; let since=createdAt; if(start>=0) since = history[start].t || since;
      for(let i=start+1;i<history.length;i++){
        const h = history[i];
        if(h.counter_id!==counterId) continue; // filter by active counter
        if(h.type==='enter'){ inside += (h.amount||0); total += (h.amount||0); }
        else if(h.type==='exit'){ inside = Math.max(0, inside - (h.amount||0)); }
        else if(h.type==='adjust'){ const a=h.amount||0; inside = Math.max(0, inside + a); if(a>0) total += a; }
        else if(h.type==='clear'){ inside = 0; }
        else if(h.type==='newDay'){ inside=0; total=0; peak=0; since=h.t||since; }
        peak = Math.max(peak, inside);
      }
      return { inside, total, peak, since };
    }

    function save(){ sset(KEYS.state,state); sset(KEYS.batch,batch); sset(KEYS.pin,pin); sset(KEYS.endpoint,endpoint); sset(KEYS.session,sessionId); sset(KEYS.counter,counterId); sset(KEYS.counterLabel,counterLabel); sset(KEYS.counters,counters); sset(KEYS.queue,queue); }

    // ---- Actions ----
    function log(entry){ const a = active(); const e = { ...entry, t: Date.now(), session_id: sessionId, counter_id: a.id, counter_label: a.label }; state.history.push(e); queue.push(e); save(); }
    function enter(n=1){ const a=active(); n=clamp0(n||1)||1; const proj=state.inside+n; if(a.lockout && proj>a.cap){ log({type:'enter',amount:0,blocked:true}); render(); return;} state.inside=proj; state.total+=n; state.peak=Math.max(state.peak,state.inside); log({type:'enter',amount:n}); haptic(); render(); }
    function exit(n=1){ n=clamp0(n||1)||1; state.inside=Math.max(0,state.inside-n); log({type:'exit',amount:n}); haptic(); render(); }
    function adjust(d){ const a=active(); d=(d|0); if(d===0) return; const proj=Math.max(0,state.inside+d); if(a.lockout && d>0 && proj>a.cap){ log({type:'adjust',amount:0,blocked:true}); render(); return;} state.inside=proj; if(d>0) state.total+=d; state.peak=Math.max(state.peak,state.inside); log({type:'adjust',amount:d}); render(); }
    function undo(){ if(!state.history.length) return; state.history.pop(); const r=replay(state.history,state.createdAt); state.inside=r.inside; state.total=r.total; state.peak=r.peak; haptic(); render(); }
    function clearFloor(){ log({type:'clear'}); state.inside=0; render(); }
    function newDay(){ log({type:'newDay'}); const r=replay(state.history,Date.now()); state.inside=r.inside; state.total=r.total; state.peak=r.peak; state.createdAt=Date.now(); render(); }

    function exportCSV(){
      const rows=[["timestamp","session_id","counter_id","counter_label","type","amount","inside_after","blocked"]];
      // Export all events (all counters) as-is
      let insideByCounter = {};
      for(const h of state.history){
        const cid = h.counter_id || 'unknown';
        if(!insideByCounter[cid]) insideByCounter[cid]=0;
        if(h.type==='enter'){ insideByCounter[cid]+=(h.amount||0); }
        else if(h.type==='exit'){ insideByCounter[cid]=Math.max(0,insideByCounter[cid]-(h.amount||0)); }
        else if(h.type==='adjust'){ insideByCounter[cid]=Math.max(0,insideByCounter[cid]+(h.amount||0)); }
        else if(h.type==='clear'){ insideByCounter[cid]=0; }
        else if(h.type==='newDay'){ insideByCounter[cid]=0; }
        rows.push([new Date(h.t).toISOString(),h.session_id,h.counter_id,h.counter_label,h.type,h.amount??"",insideByCounter[cid],h.blocked?"yes":""]);
      }
      const csv=rows.map(r=>r.join(',')).join('\n'); const blob=new Blob([csv],{type:'text/csv'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=`people_counter_${sessionId}.csv`; a.click(); URL.revokeObjectURL(a.href);
    }

    // ---- Counter management ----
    function setActiveCounter(id){
      const c = counters.find(x=>x.id===id);
      if(!c) return;
      counterId = c.id; counterLabel = c.label;
      // recompute inside/total for new active counter
      const r = replay(state.history, state.createdAt);
      state.inside=r.inside; state.total=r.total; state.peak=r.peak;
      save(); render();
    }
    function addCounter(){
      const label = (newCounterLabel.value||'').trim();
      const id = (newCounterId.value||'').trim() || label.toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/(^-|-$)/g,'');
      if(!label || !id) { alert('Enter label and/or ID'); return; }
      if(counters.find(c=>c.id===id)) { alert('That ID already exists'); return; }
      counters.push({id, label, cap: 300, lockout: false}); newCounterLabel.value=''; newCounterId.value=''; save(); render();
    }
    function deleteCounter(id){
      const idx = counters.findIndex(c=>c.id===id);
      if(idx<0) return;
      if(counters.length<=1){ alert('Keep at least one counter'); return; }
      const deletingActive = counters[idx].id===counterId;
      counters.splice(idx,1);
      if(deletingActive){ const c = counters[0]; counterId=c.id; counterLabel=c.label; }
      // recompute for possibly new active
      const r = replay(state.history, state.createdAt);
      state.inside=r.inside; state.total=r.total; state.peak=r.peak;
      save(); render();
    }

    function renderCounters(){
      const a = active();
      countersList.innerHTML='';
      for(const c of counters){
        const li = document.createElement('li'); li.className='item';
        li.innerHTML = `
          <div style="display:flex;align-items:center;gap:10px">
            <input type="radio" name="counterSel" value="${c.id}" ${c.id===counterId?'checked':''}/>
            <div>${c.label} <span class=\"small\" style=\"margin-left:6px;color:#888\">(${c.id})</span></div>
          </div>
          <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap;justify-content:flex-end">
            <span class="small">Cap</span>
            <input data-cap-for="${c.id}" class="input" style="width:90px" type="number" min="1" value="${c.cap}" />
            <span class="small">Lock</span>
            <label class="toggle ${c.lockout?'on':''}" data-lock-for="${c.id}"><div class="dot"></div></label>
            <button class="pill mutedBtn" data-del="${c.id}">Delete</button>
          </div>`;
        countersList.appendChild(li);
      }
      // attach events
      countersList.querySelectorAll('input[name="counterSel"]').forEach(r=>{
        r.addEventListener('change', ()=> setActiveCounter(r.value));
      });
      countersList.querySelectorAll('input[data-cap-for]').forEach(inp=>{
        inp.addEventListener('input', ()=>{
          const id = inp.getAttribute('data-cap-for');
          const c = counters.find(x=>x.id===id); if(!c) return;
          const n = Math.max(1, Math.floor(Number(inp.value)||0));
          c.cap = n; save(); if(c.id===counterId) render();
        });
      });
      countersList.querySelectorAll('[data-lock-for]').forEach(tg=>{
        tg.addEventListener('click', ()=>{
          const id = tg.getAttribute('data-lock-for');
          const c = counters.find(x=>x.id===id); if(!c) return;
          c.lockout = !c.lockout; tg.classList.toggle('on', c.lockout); save(); if(c.id===counterId) render();
        });
      });
      countersList.querySelectorAll('button[data-del]').forEach(b=>{
        b.addEventListener('click', ()=> deleteCounter(b.getAttribute('data-del')));
      });
    }

    function runTests(){
      const out=[]; const assert=(n,c,d='')=>out.push({name:n,pass:!!c,details:c?'':d}); const now=Date.now(); let H=[],r;
      H.push({type:'enter',amount:10,counter_id:'main-entrance',t:now}); r=replay(H,now); assert('enter adds inside (active main)', r.inside===10, `inside=${r.inside}`);
      H.push({type:'exit',amount:15,counter_id:'main-entrance',t:now+1}); r=replay(H,now); assert('exit clamps to 0', r.inside===0, `inside=${r.inside}`);
      H=[{type:'adjust',amount:5,counter_id:'main-entrance',t:now},{type:'adjust',amount:-50,counter_id:'main-entrance',t:now+1}]; r=replay(H,now); assert('adjust + increases total', r.total===5, `total=${r.total}`);
      H=[{type:'enter',amount:3,counter_id:'main-entrance',t:now},{type:'enter',amount:7,counter_id:'main-entrance',t:now+1},{type:'exit',amount:4,counter_id:'main-entrance',t:now+2}]; r=replay(H,now); assert('peak computed', r.peak===10, `peak=${r.peak}`);
      H.push({type:'newDay',t:now+3}); H.push({type:'enter',amount:2,counter_id:'main-entrance',t:now+4}); r=replay(H,now); assert('newDay resets', r.total===2 && r.inside===2 && r.peak===2, `i=${r.inside} t=${r.total} p=${r.peak}`);
      H=[{type:'enter',amount:5,counter_id:'main-entrance',t:now},{type:'clear',t:now+1}]; r=replay(H,now); assert('clear ‚Üí inside 0', r.inside===0, `inside=${r.inside}`);
      H=[{type:'enter',amount:2,counter_id:'main-entrance',t:now},{type:'exit',amount:1,counter_id:'main-entrance',t:now+1},{type:'exit',amount:5,counter_id:'main-entrance',t:now+2}]; r=replay(H,now); assert('not negative after exits', r.inside===0, `inside=${r.inside}`);
      return out;
    }

    // ---- Rendering ----
    function render(){
      save();
      // Active
      const a = active();
      // Header chip
      chipText.textContent = a.label || a.id;
      // Progress & labels
      const pct = percent(state.inside, a.cap);
      const color = pct>=100? 'var(--over)' : pct>=95? 'var(--danger)' : pct>=80? 'var(--warn)' : 'var(--ok)';
      fillEl.style.width = pct + '%'; fillEl.style.background = color;
      pctLabel.textContent = pct + '%'; maxLabel.textContent = 'Max ' + a.cap;
      // Numbers (for active counter only)
      countEl.textContent = state.inside;
      subEl.textContent = `Inside ¬∑ Total today ${state.total} ¬∑ Remaining ${Math.max(0, a.cap - state.inside)}`;
      // History list (last 20 for active counter)
      historyEl.innerHTML = '';
      const items = state.history.filter(h=>h.counter_id===a.id).slice(-20).reverse();
      for(const h of items){
        const li=document.createElement('li'); li.className='item';
        const label = h.blocked? `${h.type} (blocked)` : h.amount!=null? `${h.type} (${h.amount})` : h.type;
        li.innerHTML = `<div>${label} ‚Äî <span class=\"small\">${h.counter_label||h.counter_id}</span></div><div class=\"small\">${fmtTime(h.t)}</div>`;
        historyEl.appendChild(li);
      }
      // Since label & controls for active
      sinceLabel.textContent = 'Current start: ' + fmtDate(state.createdAt);
      capInput.value = a.cap;
      lockToggle.className = 'toggle' + (a.lockout? ' on' : '');

      // Connectivity fields
      endpointInput.value = endpoint; sessionInput.value = sessionId; counterInput.value = a.id; counterLabelInput.value = a.label;
      if(!endpoint){ syncLabel.textContent='Offline (no endpoint)'; syncDot.style.background='#bbb'; }
      else if(navigator.onLine){ syncLabel.textContent = queue.length? `Syncing‚Ä¶ ${queue.length} queued` : 'Online'; syncDot.style.background = queue.length? '#f59e0b' : '#10b981'; }
      else { syncLabel.textContent='Offline'; syncDot.style.background='#bbb'; }

      // Counters list
      renderCounters();
    }

    // ---- Events ----
    enterBtn.onclick = ()=> enter(batch);
    exitBtn.onclick = ()=> exit(batch);
    settingsBtn.onclick = ()=> {
      const entered = prompt('Enter 4‚Äëdigit PIN to open Settings:');
      if((entered||'') === String(pin)) sheetBack.style.display = 'flex'; else alert('Incorrect PIN');
    };
    sheetBack.onclick = ()=> { sheetBack.style.display = 'none'; };
    doneBtn.onclick = ()=> { sheetBack.style.display = 'none'; };

    capInput.oninput = (e)=> { const a=active(); const n = Math.max(1, Math.floor(Number(e.target.value)||0)); a.cap = n; save(); render(); };
    document.querySelectorAll('[data-cap]').forEach(b=> b.onclick = ()=> { const a=active(); a.cap = Number(b.getAttribute('data-cap')); save(); render(); });

    document.querySelectorAll('[data-batch]').forEach(b=> b.onclick = ()=> { batch = Number(b.getAttribute('data-batch')); sset(KEYS.batch,batch); render(); });

    lockToggle.onclick = ()=> { const a=active(); a.lockout = !a.lockout; save(); render(); };

    undoBtn.onclick = undo; clearBtn.onclick = clearFloor; newDayBtn.onclick = newDay; csvBtn.onclick = exportCSV;

    endpointInput.oninput = (e)=> { endpoint = e.target.value.trim(); save(); render(); };
    sessionInput.oninput = (e)=> { sessionId = e.target.value.trim() || sessionId; save(); render(); };
    counterInput.oninput = (e)=> { counterId = e.target.value.trim() || counterId; const c=counters.find(x=>x.id===counterId); if(c){ counterLabel=c.label; } const r=replay(state.history,state.createdAt); state.inside=r.inside; state.total=r.total; state.peak=r.peak; save(); render(); };
    counterLabelInput.oninput = (e)=> { const a=active(); a.label = e.target.value.trim() || a.label; counterLabel=a.label; save(); render(); };

    addCounterBtn.onclick = addCounter;

    testConnBtn.onclick = testConnection; flushBtn.onclick = flushQueueNow;

    window.addEventListener('keydown', (e)=>{
      if(document.activeElement && (document.activeElement.tagName==='INPUT' || document.activeElement.isContentEditable)) return;
      const k=(e.key||'').toLowerCase(); if(k==='e') enter(1); if(k==='x') exit(1); if(k==='u') undo(); if(k==='r') clearFloor();
    });

    testBtn.onclick = ()=>{ testsEl.innerHTML=''; const results=runTests(); for(const t of results){ const li=document.createElement('li'); li.className='item'; li.innerHTML = `<div>${t.name}</div><div><span class=\"badge ${t.pass?'pass':'fail'}\">${t.pass?'PASS':'FAIL'}</span>${t.details? `<span class='small' style='margin-left:6px;'>‚Äî ${t.details}</span>`:''}</div>`; testsEl.appendChild(li);} };

    window.addEventListener('online', ()=> { render(); flushQueue(); });
    window.addEventListener('offline', ()=> { render(); });

    window.addEventListener('error',(e)=>{ const msg=(e?.message||'')+''; if(/metamask/i.test(msg)){ envWarn.style.display='block'; envWarn.textContent='Host script error: '+msg+' ‚Äî ignored.'; }});
    window.addEventListener('unhandledrejection',(e)=>{ const msg=(e?.reason?.message||'')+''; if(/metamask/i.test(msg)){ envWarn.style.display='block'; envWarn.textContent='Host script error: '+msg+' ‚Äî ignored.'; }});

    // ---- Sync layer (Apps Script endpoint) ----
    async function testConnection(){
      if(!endpoint){ alert('Set the Endpoint URL first.'); return; }
      try{
        // CORS-free image ping first
        await new Promise((resolve,reject)=>{
          const img = new Image();
          const t = Date.now();
          img.onload = ()=>resolve();
          img.onerror = ()=>reject(new Error('Image ping failed'));
          img.src = endpoint + (endpoint.includes('?')?'&':'?') + 'fn=ping&_=' + t;
          setTimeout(()=>reject(new Error('Timeout')), 6000);
        });
        alert('Ping: reachable');
        return;
      }catch(e){ /* fall through to fetch */ }
      try{
        // Last-resort fetch (no-cors)
        const u = new URL(endpoint);
        u.searchParams.set('fn','ping');
        await fetch(u, { method:'GET', mode:'no-cors' });
        alert('Ping: request sent');
      }catch(e){
        alert('Ping failed: '+e.message);
      }
    }

    async function hydrate(){ if(!endpoint) return; try{ const u = new URL(endpoint); u.searchParams.set('fn','state'); u.searchParams.set('session_id', sessionId); u.searchParams.set('counter_id', counterId); const r = await fetch(u, {method:'GET'}); if(!r.ok) throw new Error('HTTP '+r.status); const j = await r.json(); if(j && typeof j.inside==='number'){ state.inside = j.inside; state.total = j.total||state.total; state.peak = Math.max(state.peak||0, j.peak||0); state.createdAt = j.createdAt||state.createdAt; // Reapply queued local events on top
          for(const q of queue){ if(q.type==='enter'){ state.inside += (q.amount||0); state.total += (q.amount||0);} else if(q.type==='exit'){ state.inside = Math.max(0, state.inside-(q.amount||0)); } else if(q.type==='adjust'){ const a=q.amount||0; state.inside = Math.max(0, state.inside+a); if(a>0) state.total += a; } else if(q.type==='clear'){ state.inside=0; } }
        }
      } catch(e){ /* stay offline */ }
      render();
    }

    async function postEvent(ev){
      if(!endpoint) return false;
      try{
        // Use text/plain to avoid CORS preflight. We don't need to read the response.
        await fetch(endpoint, {
          method:'POST',
          headers:{'Content-Type':'text/plain;charset=utf-8'},
          body: JSON.stringify(ev),
          mode:'no-cors',
          keepalive:true
        });
        return true;
      } catch(e){ return false; }
    }

    async function flushQueue(){ if(!endpoint || !navigator.onLine || !queue.length) { render(); return; } let i=0; while(i<queue.length){ const ok = await postEvent(queue[i]); if(ok){ queue.splice(i,1); } else { break; } save(); render(); } }
    function flushQueueNow(){ flushQueue(); }

    // periodic flush
    setInterval(flushQueue, 5000);

    // Initial
    // recompute for the initial active counter
    (function initRecalc(){ const r = replay(state.history, state.createdAt); state.inside=r.inside; state.total=r.total; state.peak=r.peak; })();
    hydrate();
    render();
  </script>
</body>
</html>
